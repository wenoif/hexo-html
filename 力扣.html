<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>力扣刷题 | 博客</title><meta name="author"><meta name="copyright"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="015.三合一20&#x2F;08&#x2F;06 三合一。描述如何只用一个数组来实现三个栈。你应该实现push(stackNum, value)、pop(stackNum)、isEmpty(stackNum)、peek(stackNum)方法。stackNum表示栈下标，value表示压入的值。构造函数会传入一个stackSize参数，代表每个栈的大小。示例1: 输入：[&quot;TripleInOne&amp;q">
<meta property="og:type" content="article">
<meta property="og:title" content="力扣刷题">
<meta property="og:url" content="https://github.com/wenoif/%E5%8A%9B%E6%89%A3.html">
<meta property="og:site_name" content="博客">
<meta property="og:description" content="015.三合一20&#x2F;08&#x2F;06 三合一。描述如何只用一个数组来实现三个栈。你应该实现push(stackNum, value)、pop(stackNum)、isEmpty(stackNum)、peek(stackNum)方法。stackNum表示栈下标，value表示压入的值。构造函数会传入一个stackSize参数，代表每个栈的大小。示例1: 输入：[&quot;TripleInOne&amp;q">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2020-08-04T02:18:54.000Z">
<meta property="article:modified_time" content="2021-09-06T15:50:07.272Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/wenoif/blog/WENOIF/avatar.jpg"><link rel="canonical" href="https://github.com/wenoif/%E5%8A%9B%E6%89%A3"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/blog/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/blog/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-09-06 23:50:07'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><meta name="generator" content="Hexo 5.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/wenoif/blog/WENOIF/avatar.jpg" onerror="onerror=null;src='https://cdn.jsdelivr.net/gh/wenoif/blog/WENOIF/main.jpg'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/blog/archives/"><div class="headline">文章</div><div class="length-num">40</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/blog/tags/"><div class="headline">标签</div><div class="length-num">24</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/blog/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/blog/"><i class="fa-fw iconfont icon-jia"></i><span> 博客首页</span></a></div><div class="menus_item"><a class="site-page" href="/blog/archives/"><i class="fa-fw iconfont icon-guidang1"></i><span> 文章归档</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://wenoif.github.io"><i class="fa-fw icon-jia"></i><span> 个人主页</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/blog/">博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/blog/"><i class="fa-fw iconfont icon-jia"></i><span> 博客首页</span></a></div><div class="menus_item"><a class="site-page" href="/blog/archives/"><i class="fa-fw iconfont icon-guidang1"></i><span> 文章归档</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://wenoif.github.io"><i class="fa-fw icon-jia"></i><span> 个人主页</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">力扣刷题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2020-08-04T02:18:54.000Z" title="undefined 2020-08-04 10:18:54">2020-08-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/blog/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>29分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div><article class="post-content" id="article-container"> <a id="more"></a>

<h2 id="015-三合一"><a href="#015-三合一" class="headerlink" title="015.三合一"></a>015.三合一</h2><p>20/08/06</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">三合一。描述如何只用一个数组来实现三个栈。</span><br><span class="line"></span><br><span class="line">你应该实现push(stackNum, value)、pop(stackNum)、isEmpty(stackNum)、peek(stackNum)方法。stackNum表示栈下标，value表示压入的值。</span><br><span class="line"></span><br><span class="line">构造函数会传入一个stackSize参数，代表每个栈的大小。</span><br><span class="line"></span><br><span class="line">示例1:</span><br><span class="line"></span><br><span class="line"> 输入：</span><br><span class="line">[&quot;TripleInOne&quot;, &quot;push&quot;, &quot;push&quot;, &quot;pop&quot;, &quot;pop&quot;, &quot;pop&quot;, &quot;isEmpty&quot;]</span><br><span class="line">[[1], [0, 1], [0, 2], [0], [0], [0], [0]]</span><br><span class="line"> 输出：</span><br><span class="line">[null, null, null, 1, -1, -1, true]</span><br><span class="line">说明：当栈为空时&#96;pop, peek&#96;返回-1，当栈满时&#96;push&#96;不压入元素。</span><br><span class="line">示例2:</span><br><span class="line"></span><br><span class="line"> 输入：</span><br><span class="line">[&quot;TripleInOne&quot;, &quot;push&quot;, &quot;push&quot;, &quot;push&quot;, &quot;pop&quot;, &quot;pop&quot;, &quot;pop&quot;, &quot;peek&quot;]</span><br><span class="line">[[2], [0, 1], [0, 2], [0, 3], [0], [0], [0], [0]]</span><br><span class="line"> 输出：</span><br><span class="line">[null, null, null, null, 2, 1, -1, -1]</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;three-in-one-lcci</span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>* <span class="built_in">stack</span>[<span class="number">3</span>];  <span class="comment">//三个栈</span></span><br><span class="line">    <span class="keyword">int</span> size[<span class="number">3</span>];    <span class="comment">//指针</span></span><br><span class="line">    <span class="keyword">int</span> capacity;   <span class="comment">//栈容量</span></span><br><span class="line"></span><br><span class="line">&#125; TripleInOne;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建 申请空间、初始化</span></span><br><span class="line"><span class="function">TripleInOne* <span class="title">tripleInOneCreate</span><span class="params">(<span class="keyword">int</span> stackSize)</span> </span>&#123;</span><br><span class="line">    TripleInOne* tristack=(TripleInOne*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TripleInOne));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tristack-&gt;<span class="built_in">stack</span>[i]=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*stackSize);</span><br><span class="line">        tristack-&gt;size[i]=<span class="number">0</span>;</span><br><span class="line">        tristack-&gt;capacity=stackSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tristack;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tripleInOnePush</span><span class="params">(TripleInOne* obj, <span class="keyword">int</span> stackNum, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判空，没满则插入</span></span><br><span class="line">    <span class="keyword">if</span>((obj-&gt;size)[stackNum]&lt;obj-&gt;capacity)</span><br><span class="line">    &#123;</span><br><span class="line">        obj-&gt;<span class="built_in">stack</span>[stackNum][(obj-&gt;size)[stackNum]]=value;</span><br><span class="line">        (obj-&gt;size)[stackNum]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tripleInOnePop</span><span class="params">(TripleInOne* obj, <span class="keyword">int</span> stackNum)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//弹出</span></span><br><span class="line">    <span class="keyword">if</span>((obj-&gt;size)[stackNum]==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        (obj-&gt;size)[stackNum]--;</span><br><span class="line">        <span class="keyword">return</span> obj-&gt;<span class="built_in">stack</span>[stackNum][(obj-&gt;size)[stackNum]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取栈顶</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tripleInOnePeek</span><span class="params">(TripleInOne* obj, <span class="keyword">int</span> stackNum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((obj-&gt;size)[stackNum]==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> obj-&gt;<span class="built_in">stack</span>[stackNum][(obj-&gt;size)[stackNum]<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">tripleInOneIsEmpty</span><span class="params">(TripleInOne* obj, <span class="keyword">int</span> stackNum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((obj-&gt;size)[stackNum]==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tripleInOneFree</span><span class="params">(TripleInOne* obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(obj-&gt;<span class="built_in">stack</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your TripleInOne struct will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * TripleInOne* obj = tripleInOneCreate(stackSize);</span></span><br><span class="line"><span class="comment"> * tripleInOnePush(obj, stackNum, value);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * int param_2 = tripleInOnePop(obj, stackNum);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * int param_3 = tripleInOnePeek(obj, stackNum);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * bool param_4 = tripleInOneIsEmpty(obj, stackNum);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * tripleInOneFree(obj);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>





<h2 id="014-链表求和"><a href="#014-链表求和" class="headerlink" title="014.链表求和"></a>014.链表求和</h2><p>20/08/05</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定两个用链表表示的整数，每个节点包含一个数位。</span><br><span class="line"></span><br><span class="line">这些数位是反向存放的，也就是个位排在链表首部。</span><br><span class="line"></span><br><span class="line">编写函数对这两个整数求和，并用链表形式返回结果。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：(7 -&gt; 1 -&gt; 6) + (5 -&gt; 9 -&gt; 2)，即617 + 295</span><br><span class="line">输出：2 -&gt; 1 -&gt; 9，即912</span><br><span class="line">进阶：假设这些数位是正向存放的，请再做一遍。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：(6 -&gt; 1 -&gt; 7) + (2 -&gt; 9 -&gt; 5)，即617 + 295</span><br><span class="line">输出：9 -&gt; 1 -&gt; 2，即912</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;sum-lists-lcci</span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">addTwoNumbers</span><span class="params">(struct ListNode* l1, struct ListNode* l2)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">sumhead</span>=</span>(struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">    <span class="comment">//申请头节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">sum</span>=</span>sumhead;</span><br><span class="line">    <span class="comment">//申请游标</span></span><br><span class="line">    <span class="keyword">int</span> nowflag=<span class="number">0</span>,preflag=<span class="number">0</span>,add=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//定义标志和相加的和</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(l1 || l2 || preflag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(l1)</span><br><span class="line">        &#123;</span><br><span class="line">            add+=l1-&gt;val;</span><br><span class="line">            l1=l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l2)</span><br><span class="line">        &#123;</span><br><span class="line">            add+=l2-&gt;val;</span><br><span class="line">            l2=l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        add+=preflag;</span><br><span class="line">        <span class="comment">//本次的和+上次是否超过10</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((add)&gt;=<span class="number">10</span>)</span><br><span class="line">        <span class="comment">//判断本次是否超过10</span></span><br><span class="line">        &#123;</span><br><span class="line">            nowflag=<span class="number">1</span>;</span><br><span class="line">            add=add%<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">newnode</span>=</span>(struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">        <span class="comment">//申请新节点</span></span><br><span class="line">        newnode-&gt;val=add;</span><br><span class="line">        newnode-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        sum-&gt;next=newnode;</span><br><span class="line">        <span class="comment">//新节点插入到游标后，游标后移</span></span><br><span class="line">        sum=sum-&gt;next;</span><br><span class="line">        </span><br><span class="line">        preflag=nowflag;</span><br><span class="line">        nowflag=<span class="number">0</span>;</span><br><span class="line">        add=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sumhead-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="013-零矩阵"><a href="#013-零矩阵" class="headerlink" title="013.零矩阵"></a>013.零矩阵</h2><p>20/06/18</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">编写一种算法，若M × N矩阵中某个元素为0，则将其所在的行与列清零。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[</span><br><span class="line">[1,1,1],</span><br><span class="line">[1,0,1],</span><br><span class="line">[1,1,1]</span><br><span class="line">]</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">[1,0,1],</span><br><span class="line">[0,0,0],</span><br><span class="line">[1,0,1]</span><br><span class="line">]</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[</span><br><span class="line">[0,1,2,0],</span><br><span class="line">[3,4,5,2],</span><br><span class="line">[1,3,1,5]</span><br><span class="line">]</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">[0,0,0,0],</span><br><span class="line">[0,4,5,0],</span><br><span class="line">[0,3,1,0]</span><br><span class="line">]</span><br><span class="line">通过次数6,694提交次数10,395</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;zero-matrix-lcci</span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="keyword">int</span>** matrix, <span class="keyword">int</span> matrixSize, <span class="keyword">int</span>* matrixColSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hang=matrixSize,lie=*matrixColSize;</span><br><span class="line">    <span class="keyword">int</span> *fhang=(<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*hang);</span><br><span class="line">    <span class="keyword">int</span> *flie=(<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*lie);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;hang;i++)fhang[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lie;i++)flie[i]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;hang;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;lie;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                fhang[i]=<span class="number">1</span>;</span><br><span class="line">                flie[j]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;hang;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(fhang[i]==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;lie;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            matrix[i][j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lie;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(flie[i]==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;hang;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            matrix[j][i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> matrix;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="012-URL化"><a href="#012-URL化" class="headerlink" title="012.URL化"></a>012.URL化</h2><p>20/06/18</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">URL化。编写一种方法，将字符串中的空格全部替换为%20。假定该字符串尾部有足够的空间存放新增字符，并且知道字符串的“真实”长度。（注：用Java实现的话，请使用字符数组实现，以便直接在数组上操作。）</span><br><span class="line"></span><br><span class="line">示例1:</span><br><span class="line"></span><br><span class="line">输入：&quot;Mr John Smith    &quot;, 13</span><br><span class="line">输出：&quot;Mr%20John%20Smith&quot;</span><br><span class="line">示例2:</span><br><span class="line"></span><br><span class="line">输入：&quot;               &quot;, 5</span><br><span class="line">输出：&quot;%20%20%20%20%20&quot;</span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">字符串长度在[0, 500000]范围内。</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;string-to-url-lcci</span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">replaceSpaces</span><span class="params">(<span class="keyword">char</span>* S, <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> spacenum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(S[i]==<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        spacenum++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> newspace=length+<span class="number">2</span>*spacenum;</span><br><span class="line">    S[newspace]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    newspace--;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=length<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(S[i]==<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            S[newspace--]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            S[newspace--]=<span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">            S[newspace--]=<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            S[newspace--]=S[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> S;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="011-环路检测"><a href="#011-环路检测" class="headerlink" title="011.环路检测"></a>011.环路检测</h2><p>20/06/12</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个有环链表，实现一个算法返回环路的开头节点。</span><br><span class="line">有环链表的定义：在链表中某个节点的next元素指向在它前面出现过的节点，则表明该链表存在环路。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1</span><br><span class="line">输出：tail connects to node index 1</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：head &#x3D; [1,2], pos &#x3D; 0</span><br><span class="line">输出：tail connects to node index 0</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：head &#x3D; [1], pos &#x3D; -1</span><br><span class="line">输出：no cycle</span><br><span class="line">解释：链表中没有环。</span><br><span class="line"></span><br><span class="line">进阶：</span><br><span class="line">你是否可以不用额外空间解决此题？</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;linked-list-cycle-lcci</span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.  先判断第一个是否构成循环</span></span><br><span class="line"><span class="comment">2.  两个快慢指针找交点</span></span><br><span class="line"><span class="comment">3.  重头开始与交点同步移动 直至相交</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct ListNode *<span class="title">detectCycle</span><span class="params">(struct ListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>||head-&gt;next==head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">la</span>=</span>head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">lb</span>=</span>head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(la&amp;&amp;lb)</span><br><span class="line">    &#123;</span><br><span class="line">        la=la-&gt;next;</span><br><span class="line">        lb=lb-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//if(lb-&gt;next!=NULL &amp;&amp; lb!=NULL)  报错</span></span><br><span class="line">        <span class="keyword">if</span>(lb!=<span class="literal">NULL</span> &amp;&amp; lb-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">            lb=lb-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(la==lb)</span><br><span class="line">        &#123;</span><br><span class="line">            la=head;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(la!=lb)</span><br><span class="line">    &#123;</span><br><span class="line">        la=la-&gt;next;</span><br><span class="line">        lb=lb-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> la;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="010-链表相交"><a href="#010-链表相交" class="headerlink" title="010.链表相交"></a>010.链表相交</h2><p>20/06/12</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定两个（单向）链表，判定它们是否相交并返回交点。请注意相交的定义基于节点的引用，而不是基于节点的值。换句话说，如果一个链表的第k个节点与另一个链表的第j个节点是同一节点（引用完全相同），则这两个链表相交。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,0,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3</span><br><span class="line">输出：Reference of the node with value &#x3D; 8</span><br><span class="line">输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：intersectVal &#x3D; 2, listA &#x3D; [0,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1</span><br><span class="line">输出：Reference of the node with value &#x3D; 2</span><br><span class="line">输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2</span><br><span class="line">输出：null</span><br><span class="line">输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">解释：这两个链表不相交，因此返回 null。</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line"></span><br><span class="line">如果两个链表没有交点，返回 null 。</span><br><span class="line">在返回结果后，两个链表仍须保持原有的结构。</span><br><span class="line">可假定整个链表结构中没有循环。</span><br><span class="line">程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;intersection-of-two-linked-lists-lcci</span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct ListNode *<span class="title">getIntersectionNode</span><span class="params">(struct ListNode *headA, struct ListNode *headB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(headA==<span class="literal">NULL</span>||headB==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">la</span>=</span>headA,*lb=headB;</span><br><span class="line">    <span class="keyword">while</span>(la!=lb)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(la!=<span class="literal">NULL</span>)la=la-&gt;next;</span><br><span class="line">        <span class="keyword">else</span> la=headB;</span><br><span class="line">        <span class="keyword">if</span>(lb!=<span class="literal">NULL</span>)lb=lb-&gt;next;</span><br><span class="line">        <span class="keyword">else</span> lb=headA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> la;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="009-回文链表"><a href="#009-回文链表" class="headerlink" title="009.回文链表"></a>009.回文链表</h2><p>20/06/06</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">编写一个函数，检查输入的链表是否是回文的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入： 1-&gt;2</span><br><span class="line">输出： false </span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入： 1-&gt;2-&gt;2-&gt;1</span><br><span class="line">输出： true </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">进阶：</span><br><span class="line">你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;palindrome-linked-list-lcci</span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">快慢指针找中点</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">后半段逆转</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">逐个比较</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>||head-&gt;next==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">l</span>=</span>head,*r=head;</span><br><span class="line">    <span class="keyword">while</span>(l&amp;&amp;l-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        r=r-&gt;next;</span><br><span class="line">        l=l-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">pre</span>=</span><span class="literal">NULL</span>,*temp=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(r!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pre=r-&gt;next;</span><br><span class="line">        r-&gt;next=temp;</span><br><span class="line">        temp=r;</span><br><span class="line">        r=pre;</span><br><span class="line">    &#125;</span><br><span class="line">    l=head;</span><br><span class="line">    <span class="keyword">while</span>(temp!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(l-&gt;val==temp-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            l=l-&gt;next;</span><br><span class="line">            temp=temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span>  <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="008-返回倒数第-k-个节点"><a href="#008-返回倒数第-k-个节点" class="headerlink" title="008.返回倒数第 k 个节点"></a>008.返回倒数第 k 个节点</h2><p>20/06/05</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。</span><br><span class="line"></span><br><span class="line">注意：本题相对原题稍作改动</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入： 1-&gt;2-&gt;3-&gt;4-&gt;5 和 k &#x3D; 2</span><br><span class="line">输出： 4</span><br><span class="line">说明：</span><br><span class="line"></span><br><span class="line">给定的 k 保证是有效的。</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;kth-node-from-end-of-list-lcci</span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthToLast</span><span class="params">(struct ListNode* head, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">l</span>=</span>head,*r=head;</span><br><span class="line">    <span class="keyword">int</span> i=k;</span><br><span class="line">    <span class="keyword">while</span>(r-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        r=r-&gt;next;</span><br><span class="line">        i--;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            l=l-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l-&gt;val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="007-旋转矩阵"><a href="#007-旋转矩阵" class="headerlink" title="007.旋转矩阵"></a>007.旋转矩阵</h2><p>20/06/04</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给你一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。</span><br><span class="line"></span><br><span class="line">不占用额外内存空间能否做到？</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">给定 matrix &#x3D; </span><br><span class="line">[</span><br><span class="line">[1,2,3],</span><br><span class="line">[4,5,6],</span><br><span class="line">[7,8,9]</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">[7,4,1],</span><br><span class="line">[8,5,2],</span><br><span class="line">[9,6,3]</span><br><span class="line">]</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">给定 matrix &#x3D;</span><br><span class="line">[</span><br><span class="line">[ 5, 1, 9,11],</span><br><span class="line">[ 2, 4, 8,10],</span><br><span class="line">[13, 3, 6, 7],</span><br><span class="line">[15,14,12,16]</span><br><span class="line">], </span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">[15,13, 2, 5],</span><br><span class="line">[14, 3, 4, 1],</span><br><span class="line">[12, 6, 8, 9],</span><br><span class="line">[16, 7,10,11]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;rotate-matrix-lcci</span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//找规律</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>** matrix, <span class="keyword">int</span> matrixSize, <span class="keyword">int</span>* matrixColSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">0</span>,r=matrixSize,i,j,t;</span><br><span class="line">    <span class="comment">//l,r表示左右边界，i,j表示坐标,t是临时变量</span></span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        i=l;j=l;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;r<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            t=matrix[i][j];</span><br><span class="line">            matrix[i][j]=matrix[matrixSize-j<span class="number">-1</span>][i];</span><br><span class="line">            matrix[matrixSize-j<span class="number">-1</span>][i]=matrix[matrixSize-i<span class="number">-1</span>][matrixSize-j<span class="number">-1</span>];</span><br><span class="line">            matrix[matrixSize-i<span class="number">-1</span>][matrixSize-j<span class="number">-1</span>]=matrix[j][matrixSize-i<span class="number">-1</span>];</span><br><span class="line">            matrix[j][matrixSize-i<span class="number">-1</span>]=t;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        ++l;--r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="006-移除重复节点"><a href="#006-移除重复节点" class="headerlink" title="006.移除重复节点"></a>006.移除重复节点</h2><p>20/06/02</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。</span><br><span class="line"></span><br><span class="line">示例1:</span><br><span class="line"></span><br><span class="line">输入：[1, 2, 3, 3, 2, 1]</span><br><span class="line">输出：[1, 2, 3]</span><br><span class="line">示例2:</span><br><span class="line"></span><br><span class="line">输入：[1, 1, 1, 1, 2]</span><br><span class="line">输出：[1, 2]</span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">链表长度在[0, 20000]范围内。</span><br><span class="line">链表元素在[0, 20000]范围内。</span><br><span class="line">进阶：</span><br><span class="line"></span><br><span class="line">如果不得使用临时缓冲区，该怎么解决？</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;remove-duplicate-node-lcci</span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//让重复出现的结点的前一个和后一个相连，以达到剔除的目的</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">removeDuplicateNodes</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(head-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">FirstHead</span>=</span>head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">This</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">AfterThis</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(FirstHead)</span><br><span class="line">    &#123;</span><br><span class="line">        This=FirstHead;</span><br><span class="line">        AfterThis=This-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(AfterThis)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(FirstHead-&gt;val==AfterThis-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                This-&gt;next=AfterThis-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                This=AfterThis;</span><br><span class="line">            &#125;</span><br><span class="line">            AfterThis=AfterThis-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        FirstHead=FirstHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>##　005.字符串轮转</p>
<p>20/06/01</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">字符串轮转。给定两个字符串s1和s2，请编写代码检查s2是否为s1旋转而成（比如，waterbottle是erbottlewat旋转后的字符串）。</span><br><span class="line"></span><br><span class="line">示例1:</span><br><span class="line"></span><br><span class="line">输入：s1 &#x3D; &quot;waterbottle&quot;, s2 &#x3D; &quot;erbottlewat&quot;</span><br><span class="line">输出：True</span><br><span class="line">示例2:</span><br><span class="line"></span><br><span class="line">输入：s1 &#x3D; &quot;aa&quot;, s2 &#x3D; &quot;aba&quot;</span><br><span class="line">输出：False</span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">字符串长度在[0, 100000]范围内。</span><br><span class="line">说明:</span><br><span class="line"></span><br><span class="line">你能只调用一次检查子串的方法吗？</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;string-rotation-lcci</span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isFlipedString</span><span class="params">(<span class="keyword">char</span>* s1, <span class="keyword">char</span>* s2)</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(s1) != <span class="built_in">strlen</span>(s2))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s1);</span><br><span class="line">    <span class="comment">//char* s = (char*)malloc(sizeof(char) * len * 2 + 1);</span></span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">2</span>*len+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s[i] = s1[i % len];</span><br><span class="line">    &#125;</span><br><span class="line">    s[<span class="number">2</span> * len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(s, s2) != <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="004-删除中间节点"><a href="#004-删除中间节点" class="headerlink" title="004.删除中间节点"></a>004.删除中间节点</h2><p>20/05/31</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">实现一种算法，删除单向链表中间的某个节点（即不是第一个或最后一个节点），假定你只能访问该节点。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：单向链表a-&gt;b-&gt;c-&gt;d-&gt;e-&gt;f中的节点c</span><br><span class="line">结果：不返回任何数据，但该链表变为a-&gt;b-&gt;d-&gt;e-&gt;f</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;delete-middle-node-lcci</span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">linked</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">linked</span>* <span class="title">Next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">linked</span> <span class="title">LINK</span>;</span></span><br><span class="line"><span class="function">LINK* <span class="title">create</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LINK* <span class="built_in">list</span>;</span><br><span class="line">	<span class="built_in">list</span> = (LINK*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LINK));</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;申请链表失败&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">list</span>-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="built_in">list</span>-&gt;data = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listADD</span><span class="params">(LINK* <span class="built_in">list</span>, <span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	LINK* AtLast = <span class="built_in">list</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (AtLast-&gt;Next!= <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		AtLast = AtLast-&gt;Next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	LINK* TemporaryList = create();</span><br><span class="line">	TemporaryList-&gt;data = data;</span><br><span class="line">	TemporaryList-&gt;Next = AtLast-&gt;Next;</span><br><span class="line"></span><br><span class="line">	AtLast-&gt;Next = TemporaryList;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listDELinHalf</span><span class="params">(LINK* <span class="built_in">list</span>)</span><span class="comment">//传入中间元素并删除</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	//方法一</span></span><br><span class="line"><span class="comment">	LINK* TemporaryList = list-&gt;Next;</span></span><br><span class="line"><span class="comment">	*list = *TemporaryList;</span></span><br><span class="line"><span class="comment">	free(TemporaryList);</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//方法二</span></span><br><span class="line">	<span class="built_in">list</span>-&gt;data = <span class="built_in">list</span>-&gt;Next-&gt;data;</span><br><span class="line">	LINK* newP = <span class="built_in">list</span>-&gt;Next;</span><br><span class="line">	<span class="built_in">list</span>-&gt;Next = newP-&gt;Next;</span><br><span class="line">	<span class="built_in">free</span>(newP);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listTraverse</span><span class="params">(LINK* <span class="built_in">list</span>)</span><span class="comment">//遍历输出</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LINK* TemporaryList = <span class="built_in">list</span>-&gt;Next;</span><br><span class="line">	<span class="keyword">while</span> (TemporaryList!= <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d-&quot;</span>, TemporaryList-&gt;data);</span><br><span class="line">		TemporaryList = TemporaryList-&gt;Next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LINK* <span class="built_in">list</span> = create();</span><br><span class="line">	listADD(<span class="built_in">list</span>, <span class="number">2</span>);</span><br><span class="line">	listADD(<span class="built_in">list</span>, <span class="number">3</span>);</span><br><span class="line">	listADD(<span class="built_in">list</span>, <span class="number">4</span>);</span><br><span class="line">	listADD(<span class="built_in">list</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">	listTraverse(<span class="built_in">list</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	listDELinHalf(<span class="built_in">list</span>-&gt;Next-&gt;Next-&gt;Next);</span><br><span class="line">	<span class="comment">//printf(&quot;%d&quot;, list-&gt;Next-&gt;Next-&gt;data);</span></span><br><span class="line">	listTraverse(<span class="built_in">list</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="003-两数之和"><a href="#003-两数之和" class="headerlink" title="003.两数之和"></a>003.两数之和</h2><p>20/05/30</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</span><br><span class="line"></span><br><span class="line">你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9</span><br><span class="line"></span><br><span class="line">因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9</span><br><span class="line">所以返回 [0, 1]</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;two-sum</span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">最初看题解是使用哈希,也不懂没了解哈希,臆测出了一种类似哈希的方法吧,但是在指针用法上力扣官网提交代码 和 本地VS调试运行 时候有所分歧(见&quot;代码一&quot;第5.6行)</span><br><span class="line"></span><br><span class="line">代码一思路:</span><br><span class="line">	1.建一维数组并初始化0</span><br><span class="line">	2.标志target遍历减去数组中的元素</span><br><span class="line">		3.每遍减去一个，在数组中寻找差值</span><br><span class="line">			4.没找到，将被减元素放入数组</span><br><span class="line">			5.找到了，返回被减元素下标 和 找到的元素下标</span><br><span class="line"></span><br><span class="line">代码二思路:循环暴力算法求解</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">twoSum</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> target, <span class="keyword">int</span>* returnSize)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">2</span>;returnSize = &amp;k;<span class="comment">//力扣报错 vs可过</span></span><br><span class="line">	<span class="comment">//*returnSize = 2;	//力扣可过  vs报错</span></span><br><span class="line">	<span class="keyword">if</span> (nums == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">int</span>* temporary = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * numsSize);</span><br><span class="line">	<span class="keyword">int</span>* answer = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++)temporary[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> poor = target - nums[i];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (temporary[j] == poor) &#123;</span><br><span class="line">				answer[<span class="number">0</span>] = j;</span><br><span class="line">				answer[<span class="number">1</span>] = i;</span><br><span class="line">				<span class="keyword">return</span> answer;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		temporary[i] = nums[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[] = &#123; <span class="number">2</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">15</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span>* returnSize = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span>* answerr = twoSum(a, <span class="keyword">sizeof</span>(a), <span class="number">9</span>, returnSize);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>, answerr[<span class="number">0</span>], answerr[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">twoSum</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> target, <span class="keyword">int</span>* returnSize)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">2</span>; returnSize = &amp;k;<span class="comment">//力扣报错 vs可过</span></span><br><span class="line">	<span class="comment">//*returnSize = 2;	//力扣可过  vs报错</span></span><br><span class="line">	<span class="keyword">if</span> (nums == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">int</span>* p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; numsSize; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> ((nums[i] + nums[j] == target)&amp;&amp;(i!=j))</span><br><span class="line">			&#123;</span><br><span class="line">				p[<span class="number">0</span>] = i;</span><br><span class="line">				p[<span class="number">1</span>] = j;</span><br><span class="line">				<span class="keyword">return</span> p;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="002-打家劫舍-DP"><a href="#002-打家劫舍-DP" class="headerlink" title="002.打家劫舍(DP)"></a>002.打家劫舍(DP)</h2><p>20/05/29</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</span><br><span class="line"></span><br><span class="line">给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。</span><br><span class="line">偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: [2,7,9,3,1]</span><br><span class="line">输出: 12</span><br><span class="line">解释: 偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。</span><br><span class="line">偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;house-robber</span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">判断长度是否大于1，不大于1直接返回。</span><br><span class="line"></span><br><span class="line">最初以为是奇位求和与偶位求和取大，但发现可能会出现间距2个以上的位置才能够找出最大值的情况。例如[1,1,2,3,7,2,2,7,1,2]。奇位求和14；偶位求和13；实际最大和17。</span><br><span class="line"></span><br><span class="line">然后认为在第1个和第2个元素中取其大作为第一个值，游标MAX逐次+2，然后[MAX]和[MAX+1]比较取其大加到和sum里面，直到最后一个元素。可是发现在第1个和第2个元素中取大值就会忽略第3或第4个元素。</span><br><span class="line"></span><br><span class="line">最终方案：分别以第1个元素和第2个元素为开始游标求和，标MAX逐次+2，然后[MAX]和[MAX+1]比较取其大加到和sum里面，直到最后一个元素，然后比较大小。</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(numsSize==<span class="number">1</span>)<span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> sum0=<span class="number">0</span>,sum1=<span class="number">0</span>,max;</span><br><span class="line">	</span><br><span class="line">	max=<span class="number">0</span>; </span><br><span class="line">	sum0=sum0+nums[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span>(max+=<span class="number">2</span>;max&lt;numsSize;max+=<span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(max+<span class="number">1</span>==numsSize)</span><br><span class="line">		&#123;</span><br><span class="line">			sum0=sum0+nums[max];</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(nums[max]&lt;nums[max+<span class="number">1</span>])</span><br><span class="line">		&#123;</span><br><span class="line">			max=max+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		sum0=sum0+nums[max];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	max=<span class="number">1</span>;</span><br><span class="line">	sum1=sum1+nums[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span>(max+=<span class="number">2</span>;max&lt;numsSize;max+=<span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(max+<span class="number">1</span>==numsSize)</span><br><span class="line">		&#123;</span><br><span class="line">			sum1=sum1+nums[max];</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(nums[max]&lt;nums[max+<span class="number">1</span>])</span><br><span class="line">		&#123;</span><br><span class="line">			max+=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		sum1=sum1+nums[max];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(sum0&gt;sum1)<span class="keyword">return</span> sum0;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> sum1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> b[<span class="number">5</span>]=&#123;<span class="number">2</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">1</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> c[<span class="number">11</span>]=&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">8</span>&#125;;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,rob(a,<span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>)));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,rob(b,<span class="keyword">sizeof</span>(b)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>)));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,rob(c,<span class="keyword">sizeof</span>(c)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>)));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(numsSize==<span class="number">1</span>)<span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> sum[<span class="number">2</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		sum[i]+=nums[i];</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> max=i+<span class="number">2</span>;max&lt;numsSize;max+=<span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(max+<span class="number">1</span>==numsSize)</span><br><span class="line">			&#123;</span><br><span class="line">				sum[i]+=nums[max];</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(nums[max]&lt;nums[max+<span class="number">1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				max=max+<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			sum[i]+=nums[max];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(sum[<span class="number">0</span>]&gt;sum[<span class="number">1</span>])<span class="keyword">return</span> sum[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> sum[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> b[<span class="number">5</span>]=&#123;<span class="number">2</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">1</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> c[<span class="number">11</span>]=&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">8</span>&#125;;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,rob(a,<span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>)));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,rob(b,<span class="keyword">sizeof</span>(b)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>)));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,rob(c,<span class="keyword">sizeof</span>(c)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>)));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="001-字符串压缩"><a href="#001-字符串压缩" class="headerlink" title="001.字符串压缩"></a>001.字符串压缩</h2><p>20/05/28</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串aabcccccaaa会变为a2b1c5a3。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a至z）。</span><br><span class="line"></span><br><span class="line">示例1:</span><br><span class="line"></span><br><span class="line">输入：&quot;aabcccccaaa&quot;</span><br><span class="line">输出：&quot;a2b1c5a3&quot;</span><br><span class="line">示例2:</span><br><span class="line"></span><br><span class="line">输入：&quot;abbccd&quot;</span><br><span class="line">输出：&quot;abbccd&quot;</span><br><span class="line">解释：&quot;abbccd&quot;压缩后为&quot;a1b2c2d1&quot;，比原字符串长度更长。</span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">字符串长度在[0, 50000]范围内。</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;compress-string-lcci</span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">首先要明确这道题的几个关键点：</span><br><span class="line"></span><br><span class="line">怎么知道长度溢出，退而选return S本身；</span><br><span class="line">重复字符的计数，需要从整型转为字符型；</span><br><span class="line">如果计数超过10,或100，甚至1000,10000，怎么确保我的转换不会出错，转换后的字符长度保持不变？（比如有11个a，就变成a11，其中“11”占了两个字符位）</span><br><span class="line">就上面这些问题来想出解决办法：</span><br><span class="line"></span><br><span class="line">一开始判断，凡是长度 &lt;&#x3D;2 的 S 一定是返回本身。其余的在最后比较两者长度，相同或超过都视为返回 S 本身；（我把字符串末尾&#39;\0&#39;也计入）</span><br><span class="line"></span><br><span class="line">对于从整型转为字符型的办法，最蠢的就是每加一次count，就把对应字符改变一次新的count值。我们要思考，既然每次count增加，字符都要变化，而且变化的规律和整型本身是一致的，为何不先等count自己加到无法再加的时候，再来把它转给字符呢？</span><br><span class="line"></span><br><span class="line">鉴于2)中的思考，我们就不难发现，第三个关键点已经引刃而解了。因为对于整型本身而言，无需考虑进位等等麻烦事，我们只要count的最终结果，无论你多长，我的转换只要一次。转换采用while中每次对10取余的方法，从低位到高位依次赋值给字符串；结束这个过程后就立马跳到下一个字母的计数，此时就要先录入字母，并准备新一轮计数器（++index），重新把count赋值为1</span><br><span class="line"></span><br><span class="line">我的思路中有一个点要理解，就是我的循环从1开始，也把字符串结束符&#39;\0&#39;也考虑在循环过程。前者其实看个人做法，后者要注意是我用来让他确定最后需要结束count增长从而实现整型到字符的转换的，从而也实现了给压缩后的新字符串结尾赋&#39;\0&#39;，一举两得。不过这样的话结尾的两者比较时，要比较的应该是原字符串的长度+1，不要忘了哦</span><br><span class="line"></span><br><span class="line">作者：PonderYao</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;compress-string-lcci&#x2F;solution&#x2F;cyu-yan-yi-dong-jie-fa-4msde-9211yu-61mde-100-by-b&#x2F;</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">compressString</span><span class="params">(<span class="keyword">char</span>* S)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> oldlen=<span class="built_in">strlen</span>(S);</span><br><span class="line">	<span class="keyword">if</span>(oldlen&lt;<span class="number">2</span>)<span class="keyword">return</span> S;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> *newS=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(S)*<span class="number">2</span>*oldlen);</span><br><span class="line">	<span class="keyword">int</span> cursor=<span class="number">0</span>,count=<span class="number">1</span>;<span class="comment">//表示在新串中位置的游标cursor和出现次数count </span></span><br><span class="line">	newS[<span class="number">0</span>]=S[<span class="number">0</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=oldlen;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(S[i]==S[i<span class="number">-1</span>])</span><br><span class="line">			count++;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> position=<span class="number">0</span>,j=count;</span><br><span class="line">			<span class="keyword">while</span>(j)</span><br><span class="line">			&#123;</span><br><span class="line">				position++;<span class="comment">//先用position表示出现次数的位数 </span></span><br><span class="line">				j=j/<span class="number">10</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			position+=cursor;<span class="comment">//position表示最后的长度 </span></span><br><span class="line">			cursor=position+<span class="number">1</span>;<span class="comment">//表示下一个字母的位置 </span></span><br><span class="line">			</span><br><span class="line">			<span class="keyword">while</span>(count)</span><br><span class="line">			&#123;</span><br><span class="line">				newS[position--]=(<span class="keyword">char</span>)(count%<span class="number">10</span>)+<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">				count=count/<span class="number">10</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			newS[cursor]=S[i];</span><br><span class="line">			count = <span class="number">1</span>;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(cursor&lt;oldlen)<span class="keyword">return</span> newS;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> S;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> S[]=<span class="string">&quot;aaaaaaaaaaaa&quot;</span>;</span><br><span class="line">	<span class="keyword">char</span> SS[]=<span class="string">&quot;a&quot;</span>;</span><br><span class="line">	<span class="keyword">char</span> SSS[]=<span class="string">&quot;aabbccddd&quot;</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,compressString(S));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,compressString(SS));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,compressString(SSS));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#015-%E4%B8%89%E5%90%88%E4%B8%80"><span class="toc-text">015.三合一</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#014-%E9%93%BE%E8%A1%A8%E6%B1%82%E5%92%8C"><span class="toc-text">014.链表求和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#013-%E9%9B%B6%E7%9F%A9%E9%98%B5"><span class="toc-text">013.零矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#012-URL%E5%8C%96"><span class="toc-text">012.URL化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#011-%E7%8E%AF%E8%B7%AF%E6%A3%80%E6%B5%8B"><span class="toc-text">011.环路检测</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#010-%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4"><span class="toc-text">010.链表相交</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#009-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8"><span class="toc-text">009.回文链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#008-%E8%BF%94%E5%9B%9E%E5%80%92%E6%95%B0%E7%AC%AC-k-%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="toc-text">008.返回倒数第 k 个节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#007-%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5"><span class="toc-text">007.旋转矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#006-%E7%A7%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9"><span class="toc-text">006.移除重复节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#004-%E5%88%A0%E9%99%A4%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9"><span class="toc-text">004.删除中间节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#003-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-text">003.两数之和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#002-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-DP"><span class="toc-text">002.打家劫舍(DP)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#001-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9"><span class="toc-text">001.字符串压缩</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By null</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/blog/js/utils.js"></script><script src="/blog/js/main.js"></script><script src="/blog/js/tw_cn.js"></script><script src="/blog/js/search/local-search.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>